#!/usr/bin/env python3

import re
from datetime import datetime
from os.path import basename

version = 7
encoding = "UTF-8"

def is_xml_licit_unicode_codepoint(c: int) -> bool:
  return c in [0x9, 0xA, 0xD] or 0x20<=c<=0xD7FF or 0xE000<=c<=0xFFFD or 0x10000<=c<=0x10FFFF

def xml_unicode_limit(string: str) -> str:
  """I'm pretty sure I have to replace any non-valid characters, the characters excluded from https://www.w3.org/TR/REC-xml/#charsets‚Ää, for xml parsers to like my document. I'm not sure why XML doesn't believe in most unicode characters under 20, but whatever. Netizen Jon Skeet claims this was fixed in XML 1.1 but XML 1.0 is still the dominant standard: https://stackoverflow.com/a/39698949/"""
  return ''.join([c if is_xml_licit_unicode_codepoint(ord(c)) else 'ÔøΩ' for c in string])

def xml_escape(string: str) -> str:
  string = string.replace("&","&amp;").replace('"','&quot;').replace("'","&apos;").replace("<","&lt;").replace(">","&gt;") #note that, obviously, of these replacements, &-replacing must come first.
  string = xml_unicode_limit(string)
  return string

def rss_item(pubDate: str, title_raw: str, file_name: str) -> bytes:
  # It's kind of implied that the pubDates have to be both time AND date, but we don't really have enough information to do that so we just use the rfc 822 date format https://datatracker.ietf.org/doc/html/rfc822#section-5 (2-digit day 3-letter month 4-digit year) # Actually, we just ignore the RSS specification's specification of rfc 822 format, and use YYYY-MM-DD instead. Who's going to stop us?
  try:
    with open(file_name, "r", encoding=encoding, newline="\n", errors='replace') as f: # My rss feed replaces non-unicode characters with unicode replacement characters (U+FFFD, ÔøΩ using errors='replace', because I like to use fancy unicode characters like the aforementioned emoji, which require unicode, but the XML specification (RSS documents are XML documents) defines it as a fatal error(!) "if an XML entity is determined (via default, encoding declaration, or higher-level protocol) to be in a certain encoding but contains byte sequences that are not legal in that encoding" https://www.w3.org/TR/REC-xml/#charencoding‚Ää. They have additional verbiage in there that makes it extremely clear that my previous plan of shoving arbitrary binary data into a UTF-8 xml document is NOT ALLOWED and MANDATORILY ILLEGAL.
      full_text_raw = f.read()
  except FileNotFoundError as _e:
    with open(file_name+".md", "r", encoding=encoding, newline="\n", errors='replace') as f: #special workaround due to github pages markdown filename handling
      full_text_raw = f.read()
  return f"""    <item>
      <title>{xml_escape(title_raw)}</title>
      <link>{file_name}</link>
      <pubDate>{pubDate}</pubDate>
      <guid>{file_name}</guid>
      <description>{xml_escape(full_text_raw)}</description>
    </item>
"""

rss_header = f"""<?xml version="1.0" encoding="{encoding}"?>
<rss version="2.0">
  <!-- This rss document was generated by Wyatt S Carpenter's {basename(__file__)} version {version}, using guidance from https://www.rssboard.org/rss-specification‚Ää, https://www.rssboard.org/files/sample-rss-2.xml‚Ää, and https://www.rssboard.org/rss-validator/‚Ää. -->
  <!-- pubDates are intentionally (if perhaps misguidedly) given here in YYYY-MM-DD format instead of rfc 822 date-time format, in clear defiance of the RSS standard. -->
  <channel>
    <title>Wyatt S Carpenter‚Äôs Blog</title>
    <link>https://wyattscarpenter.github.io/blog/</link>
    <description>a programming blog</description>
    <language>en-us</language>
    <lastBuildDate>{datetime.now().astimezone().strftime('%a, %d %b %Y %H:%M:%S %z')}</lastBuildDate> <!-- Note that the timezone information on my development machine is occasionally wrong when I traverse timezones, so this timezone information (though mandatory to provide in the rfc 822 format used in RSS (https://datatracker.ietf.org/doc/html/rfc822#section-5)) should not be trusted too much. -->
"""
rss_footer="""  </channel>
</rss>
"""

with open("rss.xml", "w", encoding=encoding, newline="\n") as f: #for some crazy Python reason, if you were to specify errors='replace' here, it would replace the unicode replacement characters (U+FFFD, ÔøΩ) with question marks (U+003F, ?)
  f.write(rss_header)
  with open("readme.md", "r", encoding=encoding, errors='replace', newline="\n") as file:
    for i in file:
      m = re.match(r"^(.*?): ùùÖ?ùùã? ?\[(.*)\]\((.*?)\)\s*?$", i)
      if m:
        f.write( rss_item( *m.groups() ) )
  f.write(rss_footer)
