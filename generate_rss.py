#!/usr/bin/env python3

import re
from datetime import datetime
from os.path import basename

version = 5
encoding = "UTF-8"

def xml_escape(string: str) -> str:
  return string.replace("&","&amp;").replace('"','&quot;').replace("'","&apos;").replace("<","&lt;").replace(">","&gt;") #note that, obviously, &-replacing must come first.

def rss_item(pubDate: str, title_raw: str, link: str) -> bytes:
  # It's kind of implied that the pubDates have to be both time AND date, but we don't really have enough information to do that so we just use the rfc 822 date format https://datatracker.ietf.org/doc/html/rfc822#section-5 (2-digit day 3-letter month 4-digit year) # Actually, we just ignore the RSS specification's specification of rfc 822 format, and use YYYY-MM-DD instead. Who's going to stop us?
  file_name = re.match("^\s*.*?://.*?/blog/(.*?)\s*$", link).group(1) #this regex is fairly flexible to rehosting, but does assume the paths are domain-name-and-maybe-more-stuff/blog/*
  with open(file_name, "r", encoding=encoding, newline="\n", errors='replace') as f: # My rss feed replaces non-unicode characters with unicode replacement characters (U+FFFD, � using errors='replace', because I like to use fancy unicode characters like the aforementioned emoji, which require unicode, but the XML specification (RSS documents are XML documents) defines it as a fatal error(!) "if an XML entity is determined (via default, encoding declaration, or higher-level protocol) to be in a certain encoding but contains byte sequences that are not legal in that encoding" https://www.w3.org/TR/REC-xml/#charencoding . They have additional verbiage in there that makes it extremely clear that my previous plan of shoving arbitrary binary data into a UTF-8 xml document is NOT ALLOWED and MANDATORILY ILLEGAL.
    full_text_raw = f.read()
  return f"""    <item>
      <title>{xml_escape(title_raw)}</title>
      <link>{link}</link>
      <pubDate>{pubDate}</pubDate>
      <guid>{link}</guid>
      <description>{xml_escape(full_text_raw)}</description>
    </item>
"""

rss_header = f"""<?xml version="1.0" encoding="{encoding}"?>
<rss version="2.0">
  <!-- This rss document was generated by Wyatt S Carpenter's {basename(__file__)} version {version}, using guidance from https://www.rssboard.org/rss-specification , https://www.rssboard.org/files/sample-rss-2.xml , and https://www.rssboard.org/rss-validator/ . -->
  <!-- pubDates are intentionally (if perhaps misguidedly) given here in YYYY-MM-DD format instead of rfc 822 date-time format, in clear defiance of the RSS standard. -->
  <channel>
    <title>Wyatt S Carpenter’s Blog</title>
    <link>https://wyattscarpenter.github.io/blog/</link>
    <description>a programming blog</description>
    <language>en-us</language>
    <lastBuildDate>{datetime.now().astimezone().strftime('%a, %d %b %Y %H:%M:%S %z')}</lastBuildDate> <!-- Note that the timezone information on my development machine is occasionally wrong when I traverse timezones, so this timezone information (though mandatory to provide in the rfc 822 format used in RSS (https://datatracker.ietf.org/doc/html/rfc822#section-5)) should not be trusted too much. -->
"""
rss_footer="""  </channel>
</rss>
"""

with open("rss.xml", "w", encoding=encoding) as f: #for some crazy Python reason, if you were to specify errors='replace' here, it would replace the unicode replacement characters (U+FFFD, �) with question marks (U+003F, ?)
  f.write(rss_header)
  with open("readme.md", "r", encoding=encoding, errors='replace') as file:
    for i in file:
      m = re.match("^(.*?): (.*) <?(https?://.*?)>?\s*?$", i) 
      if m:
        f.write( rss_item( *m.groups() ) )
  f.write(rss_footer)
